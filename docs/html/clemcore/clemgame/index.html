<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>clemcore.clemgame API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clemcore.clemgame</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="clemcore.clemgame.metrics" href="metrics.html">clemcore.clemgame.metrics</a></code></dt>
<dd>
<div class="desc"><p>Definition of metrics/scores that should be defined and logged for all games.
This constants should be used so that the naming is standardised across …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clemcore.clemgame.is_game"><code class="name flex">
<span>def <span class="ident">is_game</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.load_custom_game_registry"><code class="name flex">
<span>def <span class="ident">load_custom_game_registry</span></span>(<span>is_optional=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.load_game"><code class="name flex">
<span>def <span class="ident">load_game</span></span>(<span>game_spec: <a title="clemcore.clemgame.GameSpec" href="#clemcore.clemgame.GameSpec">GameSpec</a>, do_setup: bool = True, instances_name: str = None) ‑> <a title="clemcore.clemgame.GameBenchmark" href="#clemcore.clemgame.GameBenchmark">GameBenchmark</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.load_game_registry"><code class="name flex">
<span>def <span class="ident">load_game_registry</span></span>(<span>is_mandatory=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.select_game"><code class="name flex">
<span>def <span class="ident">select_game</span></span>(<span>game_name: str) ‑> <a title="clemcore.clemgame.GameSpec" href="#clemcore.clemgame.GameSpec">GameSpec</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clemcore.clemgame.DialogueGameMaster"><code class="flex name class">
<span>class <span class="ident">DialogueGameMaster</span></span>
<span>(</span><span>name: str, experiment: dict, player_models: List[<a title="clemcore.backends.Model" href="../backends/index.html#clemcore.backends.Model">Model</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Extended GameMaster, implementing turns as described in the clembench paper.
Has most logging and gameplay procedures implemented, including convenient logging methods.</p>
<p>:param name: of the game
:param player_models: to use for one or two players.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DialogueGameMaster(GameMaster):
    &#34;&#34;&#34;
    Extended GameMaster, implementing turns as described in the clembench paper.
    Has most logging and gameplay procedures implemented, including convenient logging methods.
    &#34;&#34;&#34;
    def __init__(self, name: str, experiment: dict, player_models: List[backends.Model]):
        super().__init__(name, experiment, player_models)
        # the logging works with an internal mapping of &#34;Player N&#34; -&gt; Player
        self.players_by_names: Dict[str, Player] = collections.OrderedDict()
        self.messages_by_names: Dict[str, List] = dict()
        self.current_turn: int = 0

    def get_players(self) -&gt; List[Player]:
        return list(self.players_by_names.values())

    def add_player(self, player: Player):
        &#34;&#34;&#34;
        Add a player to the game.

        Note: The players will be called in the same order as added!

        :param player: to be added to the game
        &#34;&#34;&#34;
        idx = len(self.players_by_names)
        player.descriptor = f&#34;Player {idx + 1}&#34;
        self.players_by_names[player.descriptor] = player
        self.messages_by_names[player.descriptor] = []

    def setup(self, **kwargs):
        self._on_setup(**kwargs)
        # log players
        players_descriptions = collections.OrderedDict(GM=f&#34;Game master for {self.name}&#34;)
        for name, player in self.players_by_names.items():
            players_descriptions[name] = player.get_description()
        # log player ID and description dcit:
        self.log_players(players_descriptions)

    def _on_setup(self, **kwargs):
        &#34;&#34;&#34;
        Template method: must be implemented

        Use add_player() here to add the players.

        :param kwargs: of the game instance
        &#34;&#34;&#34;
        raise NotImplementedError()

    def play(self) -&gt; None:
        self._on_before_game()
        inner_break = False
        while not inner_break and self._does_game_proceed():
            self.log_next_turn()  # not sure if we want to do this always here (or add to _on_before_turn)
            self._on_before_turn(self.current_turn)
            self.logger.info(f&#34;{self.name}: %s turn: %d&#34;, self.name, self.current_turn)
            for player in self.__player_sequence():
                if not self._does_game_proceed():
                    inner_break = True  # break outer loop without calling _does_game_proceed again
                    break  # potentially stop in between player turns
                self.prompt(player)
                while self._should_reprompt(player):
                    self._on_before_reprompt(player)
                    self.prompt(player, is_reprompt=True)
            self._on_after_turn(self.current_turn)
            self.current_turn += 1
        self._on_after_game()

    def prompt(self, player: Player, is_reprompt=False):
        # GM -&gt; Player
        history = self.messages_by_names[player.descriptor]
        assert history, f&#34;messages history must not be empty for {player.descriptor}&#34;

        last_entry = history[-1]
        assert last_entry[&#34;role&#34;] != &#34;assistant&#34;, &#34;Last entry should not be assistant &#34; \
                                                  &#34;b.c. this would be the role of the current player&#34;
        message = last_entry[&#34;content&#34;]

        action_type = &#39;send message&#39; if not is_reprompt else &#39;send message (reprompt)&#39;
        action = {&#39;type&#39;: action_type, &#39;content&#39;: message}
        self.log_event(from_=&#39;GM&#39;, to=player.descriptor, action=action)

        _prompt, _response, response_message = player(history, self.current_turn)

        # Player -&gt; GM
        action = {&#39;type&#39;: &#39;get message&#39;, &#39;content&#39;: response_message}
        # log &#39;get message&#39; event including backend/API call:
        self.log_event(from_=player.descriptor, to=&#34;GM&#34;, action=action, call=(_prompt, _response))

        # GM -&gt; GM
        self.__validate_parse_and_add_player_response(player, response_message)

    def _should_reprompt(self, player: Player):
        return False

    def _on_before_reprompt(self, player: Player):
        &#34;&#34;&#34;
        Hook

        Change the prompt to reprompt the player on e.g. an invalid response.
        Add the new prompt to the players message via self.add_user_message(player, new_prompt)

        :param player: that produced the invalid response
        &#34;&#34;&#34;
        pass

    def log_message_to(self, player: Player, message: str):
        &#34;&#34;&#34;            GM -&gt; Player        &#34;&#34;&#34;
        action = {&#39;type&#39;: &#39;send message&#39;, &#39;content&#39;: message}
        self.log_event(&#34;GM&#34;, player.descriptor, action)

    def log_message_to_self(self, message: str):
        &#34;&#34;&#34;            GM -&gt; GM        &#34;&#34;&#34;
        action = {&#39;type&#39;: &#39;metadata&#39;, &#39;content&#39;: message}
        self.log_event(&#34;GM&#34;, &#34;GM&#34;, action)

    def log_to_self(self, type_: str, value: str):
        &#34;&#34;&#34;            GM -&gt; GM        &#34;&#34;&#34;
        action = {&#39;type&#39;: type_, &#39;content&#39;: value}
        self.log_event(&#34;GM&#34;, &#34;GM&#34;, action)

    def add_message(self, player: Player, utterance: str, role: str):
        message = {&#34;role&#34;: role, &#34;content&#34;: utterance}
        history = self.messages_by_names[player.descriptor]
        history.append(message)

    def add_user_message(self, player: Player, utterance: str):
        self.add_message(player, utterance, role=&#34;user&#34;)

    def add_assistant_message(self, player: Player, utterance: str):
        self.add_message(player, utterance, role=&#34;assistant&#34;)

    def __validate_parse_and_add_player_response(self, player: Player, utterance: str):
        # todo: it seems we should change the order here: Parse should come first, and then validate.
        # While parse might throw a parsing (format error) validate would check solely for satisfied game rules.
        # Note: this would allow to cut off too long responses (during parse) and to only validate on the cut off piece.
        if self._validate_player_response(player, utterance):
            utterance = self.__parse_response(player, utterance)
            self.add_assistant_message(player, utterance)
            self._after_add_player_response(player, utterance)

    def _after_add_player_response(self, player: Player, utterance: str):
        &#34;&#34;&#34;
        Hook

        Add the utterance to other player&#39;s history, if necessary.
        To do this use the method add_user_message(other_player,utterance).

        :param player: that produced the response (or has been modified by the GM)
        :param utterance: that has been added
        &#34;&#34;&#34;
        pass

    def _validate_player_response(self, player: Player, utterance: str) -&gt; bool:
        &#34;&#34;&#34;
        Hook

        Decide if an utterance should be added.

        This is also the place to check for game end conditions.

        :param player: for which the response is added as &#34;assistant&#34; to the history
        :param utterance: to be added
        :return: the True, if the utterance is fine; False, if the response should not be added to the history
        &#34;&#34;&#34;
        return True

    def __parse_response(self, player: Player, utterance: str) -&gt; str:
        _utterance, log_action = self._on_parse_response(player, utterance)
        if _utterance == utterance:
            return utterance
        if log_action:
            action = {&#39;type&#39;: &#39;parse&#39;, &#39;content&#39;: _utterance}
            self.log_event(from_=&#34;GM&#34;, to=&#34;GM&#34;, action=action)
        return _utterance

    def _on_parse_response(self, player: Player, utterance: str) -&gt; Tuple[str, bool]:
        &#34;&#34;&#34;
        Hook

        Decide if a response utterance should be modified. If not simply return the utterance.

        When a modified utterance and a true value is returned, then a &#39;parse&#39; event is logged.

        :param player: that produced the response
        :param utterance: to be potentially modified
        :return: the (modified) utterance and if to log the parse action (default: True)
        &#34;&#34;&#34;
        return utterance, True

    def _on_before_turn(self, turn_idx: int):
        &#34;&#34;&#34;
        Hook
        &#34;&#34;&#34;
        pass

    def _on_after_turn(self, turn_idx: int):
        &#34;&#34;&#34;
        Hook
        &#34;&#34;&#34;
        pass

    def __player_sequence(self) -&gt; List[Player]:
        # basic implementation: return players in the order they are added
        return self.get_players()

    def _does_game_proceed(self) -&gt; bool:
        &#34;&#34;&#34;
        Template method: must be implemented
        &#34;&#34;&#34;
        raise NotImplementedError()

    def _on_before_game(self):
        &#34;&#34;&#34;
        Hook
        &#34;&#34;&#34;
        pass

    def _on_after_game(self):
        &#34;&#34;&#34;
        Hook
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></li>
<li><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></li>
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.DialogueGameMaster.add_assistant_message"><code class="name flex">
<span>def <span class="ident">add_assistant_message</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>, utterance: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.add_message"><code class="name flex">
<span>def <span class="ident">add_message</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>, utterance: str, role: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.add_player"><code class="name flex">
<span>def <span class="ident">add_player</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a player to the game.</p>
<p>Note: The players will be called in the same order as added!</p>
<p>:param player: to be added to the game</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.add_user_message"><code class="name flex">
<span>def <span class="ident">add_user_message</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>, utterance: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_players"><code class="name flex">
<span>def <span class="ident">get_players</span></span>(<span>self) ‑> List[<a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.log_message_to"><code class="name flex">
<span>def <span class="ident">log_message_to</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>GM -&gt; Player</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.log_message_to_self"><code class="name flex">
<span>def <span class="ident">log_message_to_self</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>GM -&gt; GM</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.log_to_self"><code class="name flex">
<span>def <span class="ident">log_to_self</span></span>(<span>self, type_: str, value: str)</span>
</code></dt>
<dd>
<div class="desc"><p>GM -&gt; GM</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.prompt"><code class="name flex">
<span>def <span class="ident">prompt</span></span>(<span>self, player: <a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a>, is_reprompt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameMaster.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.interactions" href="#clemcore.clemgame.GameRecorder.interactions">interactions</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_current_turn" href="#clemcore.clemgame.GameRecorder.log_current_turn">log_current_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_event" href="#clemcore.clemgame.GameRecorder.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_key" href="#clemcore.clemgame.GameRecorder.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_next_turn" href="#clemcore.clemgame.GameRecorder.log_next_turn">log_next_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.play" href="#clemcore.clemgame.GameMaster.play">play</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.setup" href="#clemcore.clemgame.GameMaster.setup">setup</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.store_records" href="#clemcore.clemgame.GameRecorder.store_records">store_records</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameBenchmark"><code class="flex name class">
<span>class <span class="ident">GameBenchmark</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>The GameBenchmark organizes the run of a particular collection of game instances
which compose a benchmark for the game. It supports different experiment conditions for games.</p>
<p>:param name: of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameBenchmark(GameResourceLocator):
    &#34;&#34;&#34;
    The GameBenchmark organizes the run of a particular collection of game instances
    which compose a benchmark for the game. It supports different experiment conditions for games.
    &#34;&#34;&#34;

    def __init__(self, name: str):
        super().__init__(name)
        self.instances = None
        self.filter_experiment: List[str] = []

    def get_description(self) -&gt; str:
        &#34;&#34;&#34;
        A short string describing the game. Will be shown when listing the games.
        :return: game description
        &#34;&#34;&#34;
        raise NotImplementedError()

    def setup(self, game_path: str, instances_name: str = None):
        self.game_dir = game_path
        self.instances = self.load_instances(game_path, instances_name)

    def build_transcripts(self, results_dir: str = None):
        results_root = file_utils.results_root(results_dir)
        dialogue_partners = [file for file in os.listdir(results_root)
                             if os.path.isdir(os.path.join(results_root, file))]
        for dialogue_pair in dialogue_partners:
            game_result_path = self.results_path_for(results_root, dialogue_pair)
            if not os.path.exists(game_result_path) or not os.path.isdir(game_result_path):
                stdout_logger.info(&#34;No results directory found at: &#34; + game_result_path)
                continue

            experiment_dirs = [file for file in os.listdir(game_result_path)
                               if os.path.isdir(os.path.join(game_result_path, file))]
            if not experiment_dirs:
                stdout_logger.warning(f&#34;{self.name}: No experiments for {dialogue_pair}&#34;)
            for experiment_dir in experiment_dirs:
                experiment_path = os.path.join(game_result_path, experiment_dir)
                experiment_name = &#34;_&#34;.join(experiment_dir.split(&#34;_&#34;)[1:])  # remove leading index number
                if self.filter_experiment and experiment_name not in self.filter_experiment:
                    stdout_logger.info(f&#34;Skip experiment {experiment_name}&#34;)
                    continue
                stdout_logger.info(f&#34;Transcribe: {experiment_name}&#34;)
                experiment_config = self.load_results_json(f&#34;{experiment_dir}/experiment_{experiment_name}&#34;,
                                                           results_root, dialogue_pair)
                episode_dirs = [file for file in os.listdir(experiment_path)
                                if os.path.isdir(os.path.join(experiment_path, file))]
                error_count = 0
                for episode_dir in tqdm(episode_dirs, desc=&#34;Building transcripts&#34;):
                    try:
                        rel_episode_path = f&#34;{experiment_dir}/{episode_dir}&#34;
                        game_instance = self.load_results_json(f&#34;{rel_episode_path}/instance&#34;,
                                                               results_root, dialogue_pair)
                        game_interactions = self.load_results_json(f&#34;{rel_episode_path}/interactions&#34;,
                                                                   results_root, dialogue_pair)

                        transcript = transcript_utils.build_transcript(game_interactions, experiment_config,
                                                                       game_instance, dialogue_pair)
                        self.store_results_file(transcript, &#34;transcript.html&#34;,
                                                dialogue_pair,
                                                sub_dir=rel_episode_path,
                                                root_dir=results_root)
                        transcript_tex = transcript_utils.build_tex(game_interactions)
                        self.store_results_file(transcript_tex, &#34;transcript.tex&#34;,
                                                dialogue_pair,
                                                sub_dir=rel_episode_path,
                                                root_dir=results_root)
                    except Exception:  # continue with other episodes if something goes wrong
                        self.logger.exception(f&#34;{self.name}: Cannot transcribe {episode_dir} (but continue)&#34;)
                        error_count += 1
                if error_count &gt; 0:
                    stdout_logger.error(
                        f&#34;{self.name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)

    def compute_scores(self, results_dir: str = None):
        results_root = file_utils.results_root(results_dir)
        dialogue_partners = [file for file in os.listdir(results_root)
                             if os.path.isdir(os.path.join(results_root, file))]
        for dialogue_pair in dialogue_partners:
            game_result_path = self.results_path_for(results_root, dialogue_pair)
            if not os.path.exists(game_result_path) or not os.path.isdir(game_result_path):
                stdout_logger.info(&#34;No results directory found at: &#34; + game_result_path)
                continue

            experiment_dirs = [file for file in os.listdir(game_result_path)
                               if os.path.isdir(os.path.join(game_result_path, file))]
            if not experiment_dirs:
                stdout_logger.warning(f&#34;{self.name}: No experiments for {dialogue_pair}&#34;)
            for experiment_dir in experiment_dirs:
                experiment_path = os.path.join(game_result_path, experiment_dir)
                experiment_name = &#34;_&#34;.join(experiment_dir.split(&#34;_&#34;)[1:])  # remove leading index number
                if self.filter_experiment and experiment_name not in self.filter_experiment:
                    stdout_logger.info(f&#34;Skip experiment {experiment_name}&#34;)
                    continue
                stdout_logger.info(f&#34;Scoring: {experiment_name}&#34;)
                experiment_config = self.load_results_json(f&#34;{experiment_dir}/experiment_{experiment_name}&#34;,
                                                           results_root, dialogue_pair)
                episode_dirs = [file for file in os.listdir(experiment_path)
                                if os.path.isdir(os.path.join(experiment_path, file))]
                error_count = 0
                for episode_dir in tqdm(episode_dirs, desc=&#34;Scoring episodes&#34;):
                    try:
                        rel_episode_path = f&#34;{experiment_dir}/{episode_dir}&#34;
                        game_instance = self.load_results_json(f&#34;{rel_episode_path}/instance&#34;,
                                                               results_root, dialogue_pair)
                        game_interactions = self.load_results_json(f&#34;{rel_episode_path}/interactions&#34;,
                                                                   results_root, dialogue_pair)

                        game_scorer = self.create_game_scorer(experiment_config, game_instance)
                        game_scorer.compute_scores(game_interactions)
                        game_scorer.store_scores(results_root, dialogue_pair, rel_episode_path)
                    except Exception:  # continue with other episodes if something goes wrong
                        self.logger.exception(f&#34;{self.name}: Cannot score {episode_dir} (but continue)&#34;)
                        error_count += 1
                if error_count &gt; 0:
                    stdout_logger.error(
                        f&#34;{self.name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)

    def run(self, player_models: List[backends.Model], results_dir: str = None):
        &#34;&#34;&#34;
        Runs game-play on all game instances for a game.
        There must be an instances.json with the following structure:
        &#34;experiments&#34;: [ # this is required
            {
                &#34;name&#34;: &lt;experiment-name&gt;, # this is required
                &#34;param1&#34;: &#34;value1&#34;, # optional
                &#34;param2&#34;: &#34;value2&#34;, # optional
                &#34;game_instances&#34;: [ # this is required
                    {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... },
                    {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... }
                ]
            }
        ]

        The instances will be automatically stored in &#34;game-name&#34; with the following structure:
            - results
                - pairing
                    - game-name
                        - experiment_name
                            - experiment.json
                            - episode_id
                                - instance.json
                                - interaction.json
        &#34;&#34;&#34;
        results_root = file_utils.results_root(results_dir)
        experiments: List = self.instances[&#34;experiments&#34;]
        if not experiments:
            self.logger.warning(f&#34;{self.name}: No experiments for %s&#34;, self.name)
        total_experiments = len(experiments)
        for experiment_idx, experiment in enumerate(experiments):
            experiment_name = experiment[&#39;name&#39;]
            if self.filter_experiment and experiment_name not in self.filter_experiment:
                stdout_logger.info(f&#34;Skip experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
                continue
            stdout_logger.info(f&#34;Run experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
            # Determine dialogue partners: How often to run the experiment with different partners
            dialogue_partners: List[List[backends.Model]] = []

            if player_models:  # favor runtime argument over experiment config
                dialogue_partners = [player_models]
            elif &#34;dialogue_partners&#34; in experiment:  # edge-case when names are given in experiment config
                for dialogue_pair_names in experiment[&#34;dialogue_partners&#34;]:
                    player_models = []
                    for model_name in dialogue_pair_names:
                        player_model = backends.get_model_for(model_name)
                        player_models.append(player_model)
                    dialogue_partners.append(player_models)
                self.logger.info(f&#34;{self.name}: Detected &#39;dialogue_partners&#39; in experiment config. &#34;
                                 f&#34;Will run with: {dialogue_partners}&#34;)

            if not dialogue_partners:
                message = (f&#34;{self.name}: Neither &#39;dialogue_partners&#39; set in experiment instance&#34;
                           f&#34; nor &#39;models&#39; given as run arg&#34;)
                stdout_logger.error(message)
                raise ValueError(message)

            for dialogue_pair in dialogue_partners:
                if self.is_single_player():
                    if len(dialogue_pair) &gt; 1:
                        message = f&#34;Too many player for singe-player game &#39;{self.name}&#39;: &#39;{len(dialogue_partners)}&#39;&#34;
                        stdout_logger.error(message)
                        raise ValueError(message)
                    model_0 = dialogue_pair[0]
                    model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
                    # still we store to model--model dir (virtual self-play)
                    dialogue_pair_desc = f&#34;{model_0}--{model_0}&#34;
                else:  # 2-players
                    if len(dialogue_pair) &gt; 2:
                        message = f&#34;Too many player for two-player game &#39;{self.name}&#39;: &#39;{len(dialogue_partners)}&#39;&#34;
                        stdout_logger.error(message)
                        raise ValueError(message)
                    if len(dialogue_pair) == 1:
                        dialogue_pair.append(dialogue_pair[0])  # model expansion
                    model_0 = dialogue_pair[0]
                    model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
                    model_1 = dialogue_pair[1]
                    model_1 = f&#34;{model_1.get_name()}-t{model_1.get_temperature()}&#34;
                    dialogue_pair_desc = f&#34;{model_0}--{model_1}&#34;
                episode_counter = 0

                self.logger.info(&#34;Activity: %s Experiment: %s Partners: %s Episode: %d&#34;,
                                 self.name, experiment_name, dialogue_pair_desc, episode_counter)

                experiment_record_dir = f&#34;{experiment_idx}_{experiment_name}&#34;
                experiment_config = {k: experiment[k] for k in experiment if k != &#39;game_instances&#39;}

                # Add some important infos to track
                experiment_config[&#34;timestamp&#34;] = datetime.now().isoformat()
                experiment_config[&#34;dialogue_partners&#34;] = dialogue_pair_desc

                self.store_results_file(experiment_config,
                                        f&#34;experiment_{experiment_name}.json&#34;,
                                        dialogue_pair_desc,
                                        sub_dir=experiment_record_dir,
                                        root_dir=results_root)

                error_count = 0
                time_experiment_start = datetime.now()
                game_instances: List = experiment[&#34;game_instances&#34;]
                for game_instance in tqdm(game_instances, desc=&#34;Playing games&#34;):
                    game_id = game_instance[&#34;game_id&#34;]
                    self.logger.info(&#34;Activity: %s Experiment: %s Episode: %d Game: %s&#34;,
                                     self.name, experiment_name, episode_counter, game_id)
                    episode_dir = experiment_record_dir + f&#34;/episode_{episode_counter}&#34;
                    self.store_results_file(game_instance,
                                            f&#34;instance.json&#34;,
                                            dialogue_pair_desc,
                                            sub_dir=episode_dir,
                                            root_dir=results_root)
                    try:
                        game_master = self.create_game_master(experiment_config, dialogue_pair)
                        game_master.setup(**game_instance)
                        game_master.play()
                        game_master.store_records(results_root, dialogue_pair_desc, episode_dir)
                    except Exception:  # continue with other episodes if something goes wrong
                        self.logger.exception(f&#34;{self.name}: Exception for episode {game_id} (but continue)&#34;)
                        error_count += 1
                    episode_counter += 1
                if error_count &gt; 0:
                    stdout_logger.error(
                        f&#34;{self.name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)
                # Add experiment duration and overwrite file
                time_experiment_end = datetime.now() - time_experiment_start
                experiment_config[&#34;duration&#34;] = str(time_experiment_end)
                self.store_results_file(experiment_config,
                                        f&#34;experiment_{experiment_name}.json&#34;,
                                        dialogue_pair_desc,
                                        sub_dir=experiment_record_dir,
                                        root_dir=results_root)

    def is_single_player(self) -&gt; bool:
        &#34;&#34;&#34;
        Decide if only a single cLLM is part of the interaction.

        :return: true, when &#39;-m all&#39; should not try all model combinations, but only all models individually
        &#34;&#34;&#34;
        return False

    def create_game_master(self, experiment: Dict, player_models: List[backends.Model]) -&gt; GameMaster:
        raise NotImplementedError()

    def create_game_scorer(self, experiment: Dict, game_instance: Dict) -&gt; GameScorer:
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameBenchmark.build_transcripts"><code class="name flex">
<span>def <span class="ident">build_transcripts</span></span>(<span>self, results_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.compute_scores"><code class="name flex">
<span>def <span class="ident">compute_scores</span></span>(<span>self, results_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.create_game_master"><code class="name flex">
<span>def <span class="ident">create_game_master</span></span>(<span>self, experiment: Dict, player_models: List[<a title="clemcore.backends.Model" href="../backends/index.html#clemcore.backends.Model">Model</a>]) ‑> <a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.create_game_scorer"><code class="name flex">
<span>def <span class="ident">create_game_scorer</span></span>(<span>self, experiment: Dict, game_instance: Dict) ‑> <a title="clemcore.clemgame.GameScorer" href="#clemcore.clemgame.GameScorer">GameScorer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.get_description"><code class="name flex">
<span>def <span class="ident">get_description</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>A short string describing the game. Will be shown when listing the games.
:return: game description</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.is_single_player"><code class="name flex">
<span>def <span class="ident">is_single_player</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Decide if only a single cLLM is part of the interaction.</p>
<p>:return: true, when '-m all' should not try all model combinations, but only all models individually</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, player_models: List[<a title="clemcore.backends.Model" href="../backends/index.html#clemcore.backends.Model">Model</a>], results_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs game-play on all game instances for a game.
There must be an instances.json with the following structure:
"experiments": [ # this is required
{
"name": <experiment-name>, # this is required
"param1": "value1", # optional
"param2": "value2", # optional
"game_instances": [ # this is required
{"game_id": <value>, "initial_prompt": &hellip; },
{"game_id": <value>, "initial_prompt": &hellip; }
]
}
]</p>
<p>The instances will be automatically stored in "game-name" with the following structure:
- results
- pairing
- game-name
- experiment_name
- experiment.json
- episode_id
- instance.json
- interaction.json</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, game_path: str, instances_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameResourceLocator.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator"><code class="flex name class">
<span>class <span class="ident">GameInstanceGenerator</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create all game instances for a game benchmark.</p>
<p>Results in a instances.json with the following structure:</p>
<p>"experiments": [ # this is required
{
"name": <experiment-name>, # this is required
"param1": "value1", # optional
"param2": "value2", # optional
"game_instances": [ # this is required
{"id": <value>, "initial_prompt": &hellip; },
{"id": <value>, "initial_prompt": &hellip; }
]
}
]</p>
<p>:param name: of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameInstanceGenerator(GameResourceLocator):
    &#34;&#34;&#34;
    Create all game instances for a game benchmark.

    Results in a instances.json with the following structure:

    &#34;experiments&#34;: [ # this is required
        {
            &#34;name&#34;: &lt;experiment-name&gt;, # this is required
            &#34;param1&#34;: &#34;value1&#34;, # optional
            &#34;param2&#34;: &#34;value2&#34;, # optional
            &#34;game_instances&#34;: [ # this is required
                {&#34;id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... },
                {&#34;id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... }
            ]
        }
    ]
    &#34;&#34;&#34;

    def __init__(self, name: str):
        super().__init__(name)
        self.instances = dict(experiments=list())

    def add_experiment(self, experiment_name: str, dialogue_partners: List[Tuple[str, str]] = None) -&gt; Dict:
        &#34;&#34;&#34;
        Call this method and adjust the returned dict to configure the experiment.
        For game instances use add_game_instance!
        :param experiment_name: of the new game instance
        :param dialogue_partners: a list of partner definitions for which the experiment will run
        :return: a new game instance dict
        &#34;&#34;&#34;
        experiment = collections.OrderedDict(name=experiment_name)
        if dialogue_partners:
            experiment[&#34;dialogue_partners&#34;] = dialogue_partners
        experiment[&#34;game_instances&#34;] = list()
        self.instances[&#34;experiments&#34;].append(experiment)
        return experiment

    def add_game_instance(self, experiment: Dict, game_id):
        &#34;&#34;&#34;
        Call this method and adjust the returned dict to configure the instance.
        :param experiment: to which a new game instance should be added
        :param game_id: of the new game instance
        :return: a new game instance dict
        &#34;&#34;&#34;
        game_instance = dict(game_id=game_id)
        experiment[&#34;game_instances&#34;].append(game_instance)
        return game_instance

    def on_generate(self, **kwargs):
        &#34;&#34;&#34;
        Game-specific instance generation.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def generate(self, filename=&#34;instances.json&#34;, **kwargs):
        self.on_generate(**kwargs)
        self.store_file(self.instances, filename, sub_dir=&#34;in&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameInstanceGenerator.add_experiment"><code class="name flex">
<span>def <span class="ident">add_experiment</span></span>(<span>self, experiment_name: str, dialogue_partners: List[Tuple[str, str]] = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method and adjust the returned dict to configure the experiment.
For game instances use add_game_instance!
:param experiment_name: of the new game instance
:param dialogue_partners: a list of partner definitions for which the experiment will run
:return: a new game instance dict</p></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.add_game_instance"><code class="name flex">
<span>def <span class="ident">add_game_instance</span></span>(<span>self, experiment: Dict, game_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method and adjust the returned dict to configure the instance.
:param experiment: to which a new game instance should be added
:param game_id: of the new game instance
:return: a new game instance dict</p></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, filename='instances.json', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.on_generate"><code class="name flex">
<span>def <span class="ident">on_generate</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Game-specific instance generation.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameResourceLocator.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameMaster"><code class="flex name class">
<span>class <span class="ident">GameMaster</span></span>
<span>(</span><span>name: str, experiment: Dict, player_models: List[<a title="clemcore.backends.Model" href="../backends/index.html#clemcore.backends.Model">Model</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The game master is the master of a specific game. The master</p>
<ul>
<li>prepares a concrete game instance</li>
<li>plays an episode of a game instance</li>
<li>records a game episode</li>
<li>evaluates the game episode records</li>
<li>builds the interaction transcripts</li>
</ul>
<p>:param name: of the game
:param player_models: to use for one or two players.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameMaster(GameRecorder):
    &#34;&#34;&#34;
    The game master is the master of a specific game. The master

    - prepares a concrete game instance
    - plays an episode of a game instance
    - records a game episode
    - evaluates the game episode records
    - builds the interaction transcripts

    &#34;&#34;&#34;

    def __init__(self, name: str, experiment: Dict, player_models: List[backends.Model] = None):
        &#34;&#34;&#34;
        :param name: of the game
        :param player_models: to use for one or two players.
        &#34;&#34;&#34;
        super().__init__(name)
        self.experiment: Dict = experiment
        self.player_models: List[backends.Model] = player_models

    def setup(self, **kwargs):
        &#34;&#34;&#34;
        Load resources and prepare everything to play the game
        - Needs to log the players dictionary via self.log_players(players_dict)
        &#34;&#34;&#34;
        raise NotImplementedError()

    def play(self) -&gt; None:
        &#34;&#34;&#34;
        Play the game (multiple turns of specific a specific game instance)
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></li>
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.DialogueGameMaster" href="#clemcore.clemgame.DialogueGameMaster">DialogueGameMaster</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameMaster.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Play the game (multiple turns of specific a specific game instance)</p></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load resources and prepare everything to play the game
- Needs to log the players dictionary via self.log_players(players_dict)</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameRecorder.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.interactions" href="#clemcore.clemgame.GameRecorder.interactions">interactions</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_current_turn" href="#clemcore.clemgame.GameRecorder.log_current_turn">log_current_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_event" href="#clemcore.clemgame.GameRecorder.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_key" href="#clemcore.clemgame.GameRecorder.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_next_turn" href="#clemcore.clemgame.GameRecorder.log_next_turn">log_next_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.store_records" href="#clemcore.clemgame.GameRecorder.store_records">store_records</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameRecorder"><code class="flex name class">
<span>class <span class="ident">GameRecorder</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to game specific resources</p>
<p>Note: You should access resource only via the game resource locator! The locator knows how to refer to them.
For example use: <code>gm.load_json("my_file")</code> which is located directly at your game directory <code>game/my_file.json</code>.
You can access subdirectories by giving <code>gm.load_json("sub/my_file")</code> in <code>game/sub/my_file.json</code>.</p>
<p>:param name: of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameRecorder(GameResourceLocator):

    def __init__(self, name: str):
        super().__init__(name)
        self.log_current_turn = -1
        &#34;&#34;&#34; Stores players and turn during the runs &#34;&#34;&#34;
        self.interactions = {
            &#34;players&#34;: {},
            &#34;turns&#34;: []
        }
        &#34;&#34;&#34; Stores calls to the API &#34;&#34;&#34;
        self.requests = []

    def log_next_turn(self):
        &#34;&#34;&#34; Call this method to group interactions per turn &#34;&#34;&#34;
        self.log_current_turn += 1
        self.interactions[&#34;turns&#34;].append([])

    def log_key(self, key: str, value: Any):
        &#34;&#34;&#34;Add a key and value to the internal log.&#34;&#34;&#34;
        self.interactions[key] = value
        self.logger.info(f&#34;{self.name}: Logged a game-specific interaction key: {key}.&#34;)

    def log_players(self, players_dic: Dict):
        self.interactions[&#34;players&#34;] = players_dic
        self.logger.info(f&#34;{self.name}: Logged players metadata.&#34;)

    def log_event(self, from_: str, to: str, action: Dict, call: Tuple[Any, Any] = None):
        &#34;&#34;&#34;
        Add an event to the internal log. It can be only an action or an action
        plus an API call that should have the same timestamp as the action.

        call, if given, is a tuple whose first element is the input prompt
        object (after API-specific manipulation) as passed to the API and the
        second element is the raw response object as returned by the API.
        &#34;&#34;&#34;
        assert self.log_current_turn &gt;= 0, f&#34;Call log_add_new_turn at least once &#34; \
                                           f&#34;(log_current_turn={self.log_current_turn})&#34;
        timestamp = datetime.now().isoformat()
        action_obj = {
            &#34;from&#34;: from_,
            &#34;to&#34;: to,
            &#34;timestamp&#34;: timestamp,
            &#34;action&#34;: action
        }
        self.interactions[&#34;turns&#34;][self.log_current_turn].append(copy.deepcopy(action_obj))
        self.logger.info(
            f&#34;{self.name}: Logged {action[&#39;type&#39;]} action ({from_}-&gt;{to}).&#34;)
        if call:
            call_obj = {
                &#34;timestamp&#34;: timestamp,
                &#34;manipulated_prompt_obj&#34;: self._needs_copy(call[0]),
                &#34;raw_response_obj&#34;: self._needs_copy(call[1])
            }
            self.requests.append(call_obj)
            self.logger.info(f&#34;{self.name}: Logged a call with timestamp {timestamp}&#34;)

    @staticmethod
    def _needs_copy(call_obj):
        if isinstance(call_obj, Dict) or isinstance(call_obj, List):
            return copy.deepcopy(call_obj)
        elif isinstance(call_obj, str):
            return call_obj[:]
        return call_obj

    def store_records(self, results_root: str, dialogue_pair_desc: str, game_record_dir: str):
        &#34;&#34;&#34;Raise warnings if a mandatory element is empty or format is wrong.&#34;&#34;&#34;
        if not self.interactions[&#34;players&#34;]:
            self.logger.warning(f&#34;Players metadada is missing!&#34;)
        else:
            for name in self.interactions[&#34;players&#34;]:
                &#34;&#34;&#34;The transcript builder relies on specific player identifiers.&#34;&#34;&#34;
                try:
                    assert name == &#34;GM&#34; or name.startswith(&#34;Player &#34;)
                except AssertionError:
                    self.logger.warning(f&#34;Invalid player identifiers, html builder won&#39;t work.&#34;)
        if not self.interactions[&#34;turns&#34;]:
            self.logger.warning(f&#34;Interaction logs are missing!&#34;)
        if not self.requests:
            self.logger.warning(f&#34;No calls logged!&#34;)
        self.store_results_file(self.interactions, &#34;interactions.json&#34;,
                                dialogue_pair_desc,
                                sub_dir=game_record_dir,
                                root_dir=results_root)
        self.store_results_file(self.requests, &#34;requests.json&#34;,
                                dialogue_pair_desc,
                                sub_dir=game_record_dir,
                                root_dir=results_root)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.GameRecorder.interactions"><code class="name">var <span class="ident">interactions</span></code></dt>
<dd>
<div class="desc"><p>Stores calls to the API</p></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_current_turn"><code class="name">var <span class="ident">log_current_turn</span></code></dt>
<dd>
<div class="desc"><p>Stores players and turn during the runs</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameRecorder.log_event"><code class="name flex">
<span>def <span class="ident">log_event</span></span>(<span>self, from_: str, to: str, action: Dict, call: Tuple[Any, Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an event to the internal log. It can be only an action or an action
plus an API call that should have the same timestamp as the action.</p>
<p>call, if given, is a tuple whose first element is the input prompt
object (after API-specific manipulation) as passed to the API and the
second element is the raw response object as returned by the API.</p></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_key"><code class="name flex">
<span>def <span class="ident">log_key</span></span>(<span>self, key: str, value: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a key and value to the internal log.</p></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_next_turn"><code class="name flex">
<span>def <span class="ident">log_next_turn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method to group interactions per turn</p></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_players"><code class="name flex">
<span>def <span class="ident">log_players</span></span>(<span>self, players_dic: Dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.store_records"><code class="name flex">
<span>def <span class="ident">store_records</span></span>(<span>self, results_root: str, dialogue_pair_desc: str, game_record_dir: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Raise warnings if a mandatory element is empty or format is wrong.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameResourceLocator.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator"><code class="flex name class">
<span>class <span class="ident">GameResourceLocator</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to game specific resources</p>
<p>Note: You should access resource only via the game resource locator! The locator knows how to refer to them.
For example use: <code>gm.load_json("my_file")</code> which is located directly at your game directory <code>game/my_file.json</code>.
You can access subdirectories by giving <code>gm.load_json("sub/my_file")</code> in <code>game/sub/my_file.json</code>.</p>
<p>:param name: of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameResourceLocator(abc.ABC):
    &#34;&#34;&#34;
    Provides access to game specific resources

    Note: You should access resource only via the game resource locator! The locator knows how to refer to them.
    For example use: `gm.load_json(&#34;my_file&#34;)` which is located directly at your game directory `game/my_file.json`.
    You can access subdirectories by giving `gm.load_json(&#34;sub/my_file&#34;)` in `game/sub/my_file.json`.
    &#34;&#34;&#34;

    def __init__(self, name: str):
        &#34;&#34;&#34;
        :param name: of the game
        &#34;&#34;&#34;
        self.name = name
        self.logger = logging.getLogger(self.__class__.__module__)

    def file_path(self, file_name: str) -&gt; str:
        &#34;&#34;&#34;
        The absolute path to a game file. Sometimes we only need the path to a file, but not to load it.
        :param file_name: can be a sub-path
        :return: the absolute path to the file in the game directory
        &#34;&#34;&#34;
        return file_utils.file_path(file_name, self.name)

    def load_instances(self, game_path, instances_name):
        &#34;&#34;&#34;
        Construct instances path and return json object of the instance file
        &#34;&#34;&#34;
        if instances_name is None:
            instances_name = &#34;instances&#34;
        if not instances_name.endswith(&#34;.json&#34;):
            instances_name += &#34;.json&#34;
        if not os.path.isabs(game_path):
            game_path = os.path.join(file_utils.project_root(), game_path)
        game_file_path = os.path.join(game_path, &#34;in&#34;, instances_name)
        with open(game_file_path, encoding=&#39;utf8&#39;) as f:
            instances = json.load(f)
        return instances

    def load_template(self, file_name: str) -&gt; str:
        &#34;&#34;&#34;
        Load a .template file from your game directory
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :return: the file contents
        &#34;&#34;&#34;
        return file_utils.load_template(file_name, self.name)

    def load_json(self, file_name: str) -&gt; Dict:
        &#34;&#34;&#34;
        Load a .json file from your game (or game results) directory
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :return: the file contents
        &#34;&#34;&#34;
        return file_utils.load_json(file_name, self.name)

    def load_results_json(self, file_name: str, results_dir: str, dialogue_pair: str) -&gt; Dict:
        &#34;&#34;&#34;
        Load a .json file from your game (or game results) directory
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :return: the file contents
        &#34;&#34;&#34;
        return file_utils.load_results_json(file_name, results_dir, dialogue_pair, self.name)

    def load_csv(self, file_name: str) -&gt; Dict:
        &#34;&#34;&#34;
        Load a .csv file from your game directory
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :return: the file contents
        &#34;&#34;&#34;
        return file_utils.load_csv(file_name, self.name)

    def load_file(self, file_name: str, file_ending: str = None) -&gt; str:
        &#34;&#34;&#34;
        Load an arbitrary file from your game directory
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :param file_ending: if not given in file_name
        :return: the file contents
        &#34;&#34;&#34;
        return file_utils.load_file(file_name, self.name, file_ending=file_ending)

    def store_file(self, data, file_name: str, sub_dir: str = None):
        &#34;&#34;&#34;
        Store a file in your game directory. The top-level directory is &#39;games&#39;.

        :param sub_dir: automatically created when given; otherwise an error will be thrown.
        :param data: to store
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        &#34;&#34;&#34;
        fp = file_utils.store_game_file(data, file_name, self.name, sub_dir=sub_dir)
        self.logger.info(&#34;Game file stored to %s&#34;, fp)

    def store_results_file(self, data, file_name: str, dialogue_pair: str, sub_dir: str = None, root_dir: str = None):
        &#34;&#34;&#34;
        Store a results file in your game results&#39; directory. The top-level directory is &#39;results&#39;.

        :param sub_dir: automatically created when given; otherwise an error will be thrown.
        :param data: to store
        :param file_name: can have subdirectories e.g. &#34;sub/my_file&#34;
        :param root_dir: an alternative results directory structure given as a relative or absolute path
        &#34;&#34;&#34;
        fp = file_utils.store_game_results_file(data, file_name, dialogue_pair, self.name,
                                                sub_dir=sub_dir, root_dir=root_dir)
        self.logger.info(&#34;Results file stored to %s&#34;, fp)

    def results_path_for(self, results_dir: str, dialogue_pair: str):
        return file_utils.game_results_dir_for(results_dir, dialogue_pair, self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameBenchmark" href="#clemcore.clemgame.GameBenchmark">GameBenchmark</a></li>
<li><a title="clemcore.clemgame.GameInstanceGenerator" href="#clemcore.clemgame.GameInstanceGenerator">GameInstanceGenerator</a></li>
<li><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></li>
<li><a title="clemcore.clemgame.GameScorer" href="#clemcore.clemgame.GameScorer">GameScorer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameResourceLocator.file_path"><code class="name flex">
<span>def <span class="ident">file_path</span></span>(<span>self, file_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The absolute path to a game file. Sometimes we only need the path to a file, but not to load it.
:param file_name: can be a sub-path
:return: the absolute path to the file in the game directory</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_csv"><code class="name flex">
<span>def <span class="ident">load_csv</span></span>(<span>self, file_name: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Load a .csv file from your game directory
:param file_name: can have subdirectories e.g. "sub/my_file"
:return: the file contents</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, file_name: str, file_ending: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Load an arbitrary file from your game directory
:param file_name: can have subdirectories e.g. "sub/my_file"
:param file_ending: if not given in file_name
:return: the file contents</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_instances"><code class="name flex">
<span>def <span class="ident">load_instances</span></span>(<span>self, game_path, instances_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct instances path and return json object of the instance file</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>self, file_name: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Load a .json file from your game (or game results) directory
:param file_name: can have subdirectories e.g. "sub/my_file"
:return: the file contents</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_results_json"><code class="name flex">
<span>def <span class="ident">load_results_json</span></span>(<span>self, file_name: str, results_dir: str, dialogue_pair: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Load a .json file from your game (or game results) directory
:param file_name: can have subdirectories e.g. "sub/my_file"
:return: the file contents</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_template"><code class="name flex">
<span>def <span class="ident">load_template</span></span>(<span>self, file_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Load a .template file from your game directory
:param file_name: can have subdirectories e.g. "sub/my_file"
:return: the file contents</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.results_path_for"><code class="name flex">
<span>def <span class="ident">results_path_for</span></span>(<span>self, results_dir: str, dialogue_pair: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.store_file"><code class="name flex">
<span>def <span class="ident">store_file</span></span>(<span>self, data, file_name: str, sub_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Store a file in your game directory. The top-level directory is 'games'.</p>
<p>:param sub_dir: automatically created when given; otherwise an error will be thrown.
:param data: to store
:param file_name: can have subdirectories e.g. "sub/my_file"</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.store_results_file"><code class="name flex">
<span>def <span class="ident">store_results_file</span></span>(<span>self, data, file_name: str, dialogue_pair: str, sub_dir: str = None, root_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Store a results file in your game results' directory. The top-level directory is 'results'.</p>
<p>:param sub_dir: automatically created when given; otherwise an error will be thrown.
:param data: to store
:param file_name: can have subdirectories e.g. "sub/my_file"
:param root_dir: an alternative results directory structure given as a relative or absolute path</p></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameScorer"><code class="flex name class">
<span>class <span class="ident">GameScorer</span></span>
<span>(</span><span>name: str, experiment: Dict, game_instance: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates scores based on interaction logs.</p>
<p>:param name: of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameScorer(GameResourceLocator):
    &#34;&#34;&#34;
    Calculates scores based on interaction logs.
    &#34;&#34;&#34;
    def __init__(self, name: str, experiment: Dict, game_instance: Dict):
        super().__init__(name)
        self.experiment = experiment
        self.game_instance = game_instance
        &#34;&#34;&#34; Stores values of score computation &#34;&#34;&#34;
        self.scores = {
            &#34;turn scores&#34;: {},
            &#34;episode scores&#34;: {},
        }

    def store_scores(self, results_root: str, dialogue_pair: str, game_record_dir: str):
        self.store_results_file(self.scores, &#34;scores.json&#34;,
                                dialogue_pair=dialogue_pair,
                                sub_dir=game_record_dir,
                                root_dir=results_root)

    def log_turn_score(self, turn_idx, score_name, score_value):
        if isinstance(score_value, bool):
            self.logger.warning(f&#34;{self.name}: Score {score_name} value is boolean, this can break the eval!&#34;)
        if turn_idx not in self.scores[&#34;turn scores&#34;]:
            self.scores[&#34;turn scores&#34;][turn_idx] = {}
        if score_name in self.scores[&#34;turn scores&#34;][turn_idx]:
            self.logger.warning(f&#34;{self.name}: Score {score_name} overwritten at turn {turn_idx}!&#34;)
        self.scores[&#34;turn scores&#34;][turn_idx][score_name] = score_value
        self.logger.info(f&#34;{self.name}: Logged turn {turn_idx} score {score_name}={score_value}.&#34;)

    def log_episode_score(self, score_name, score_value):
        if score_name in self.scores[&#34;episode scores&#34;]:
            self.logger.warning(f&#34;{self.name}: Episode score {score_name} overwritten!&#34;)
        self.scores[&#34;episode scores&#34;][score_name] = score_value
        self.logger.info(f&#34;{self.name}: Logged episode score {score_name}={score_value}.&#34;)

    def compute_scores(self, episode_interactions: Dict) -&gt; None:
        self.score_turns(episode_interactions)
        self.score_game(episode_interactions)

    def score_turns(self, episode_interactions: Dict) -&gt; None:
        # Loop over turns, calculate and log turn-specific scores
        raise NotImplementedError()

    def score_game(self, episode_interactions: Dict) -&gt; None:
        self.score_game_end(episode_interactions)
        self.score_requests(episode_interactions)
        self.log_main_score(episode_interactions)

    def score_game_end(self, episode_interactions: Dict) -&gt; None:
        aborted = int(episode_interactions[ms.METRIC_ABORTED])
        lose = int(episode_interactions[ms.METRIC_LOSE]) if not aborted else 0
        success = 1 - lose if not aborted else 0

        self.log_episode_score(ms.METRIC_ABORTED, aborted)
        self.log_episode_score(ms.METRIC_LOSE, lose)
        self.log_episode_score(ms.METRIC_SUCCESS, success)

    def score_requests(self, episode_interactions: Dict):
        # logging total request count, parsed, violated, and success ratio of parsed requests over all requests
        request_count = episode_interactions[
            ms.METRIC_REQUEST_COUNT]  # could also be calculated by adding parsed and violated requests
        parsed_requests = episode_interactions[ms.METRIC_REQUEST_COUNT_PARSED]
        violated_requests = episode_interactions[ms.METRIC_REQUEST_COUNT_VIOLATED]

        self.log_episode_score(ms.METRIC_REQUEST_COUNT, request_count)
        self.log_episode_score(ms.METRIC_REQUEST_COUNT_PARSED, parsed_requests)
        self.log_episode_score(ms.METRIC_REQUEST_COUNT_VIOLATED, violated_requests)
        self.log_episode_score(ms.METRIC_REQUEST_SUCCESS, parsed_requests / request_count)

    def log_main_score(self, episode_interactions: Dict):
        # Replace this function call with a function that logs your main score aka BENCH_SCORE
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.GameScorer.game_instance"><code class="name">var <span class="ident">game_instance</span></code></dt>
<dd>
<div class="desc"><p>Stores values of score computation</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameScorer.compute_scores"><code class="name flex">
<span>def <span class="ident">compute_scores</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_episode_score"><code class="name flex">
<span>def <span class="ident">log_episode_score</span></span>(<span>self, score_name, score_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_main_score"><code class="name flex">
<span>def <span class="ident">log_main_score</span></span>(<span>self, episode_interactions: Dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_turn_score"><code class="name flex">
<span>def <span class="ident">log_turn_score</span></span>(<span>self, turn_idx, score_name, score_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_game"><code class="name flex">
<span>def <span class="ident">score_game</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_game_end"><code class="name flex">
<span>def <span class="ident">score_game_end</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_requests"><code class="name flex">
<span>def <span class="ident">score_requests</span></span>(<span>self, episode_interactions: Dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_turns"><code class="name flex">
<span>def <span class="ident">score_turns</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.store_scores"><code class="name flex">
<span>def <span class="ident">store_scores</span></span>(<span>self, results_root: str, dialogue_pair: str, game_record_dir: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.GameResourceLocator.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameSpec"><code class="flex name class">
<span>class <span class="ident">GameSpec</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for game specifications.
Holds all necessary information to play game in clembench (see README for list of attributes)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameSpec(SimpleNamespace):
    &#34;&#34;&#34;
    Base class for game specifications.
    Holds all necessary information to play game in clembench (see README for list of attributes)
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # check for required fields
        if &#34;game_name&#34; not in self:
            raise KeyError(f&#34;No game name specified in entry {kwargs}&#34;)
        if &#34;game_path&#34; not in self:
            raise KeyError(f&#34;No game path specified in {kwargs}&#34;)
        # make game_path absolute
        if not os.path.isabs(self.game_path):
            self.game_path = os.path.join(file_utils.project_root(), self.game_path)

    def __repr__(self):
        return f&#34;GameSpec({str(self)})&#34;

    def __str__(self):
        return str(self.__dict__)

    def __getitem__(self, item):
        &#34;&#34;&#34; dict-like behavior &#34;&#34;&#34;
        return getattr(self, item)

    def __contains__(self, attribute):
        &#34;&#34;&#34; dict-like behavior &#34;&#34;&#34;
        return hasattr(self, attribute)

    @classmethod
    def from_dict(cls, spec: Dict):
        &#34;&#34;&#34;
        Initialize a GameSpec from a dictionary. Can be used to directly create a GameSpec from a game registry entry.
        &#34;&#34;&#34;
        return cls(**spec)

    def matches(self, spec: Dict):
        &#34;&#34;&#34;
        Check if the game features match a given specification
        &#34;&#34;&#34;
        for key, value in spec.items():
            if not self.__contains__(key):
                raise KeyError(f&#34;The specified key &#39;{key}&#39; for selecting games is not set in the game registry &#34;
                               f&#34;for game &#39;{self[&#39;game_name&#39;]}&#39;&#34;)
            if type(self[key]) == str:
                if not self[key] == value:
                    return False
            elif type(self[key]) == list:
                if value not in self[key]:
                    return False
        return True

    def get_game_file(self):
        &#34;&#34;&#34;
        Main game file must be called master.py in game directory
        &#34;&#34;&#34;
        return os.path.join(self.game_path, &#34;master.py&#34;)

    def game_file_exists(self):
        &#34;&#34;&#34;
        Check if master.py can be located at the specified game_path
        &#34;&#34;&#34;
        return True if os.path.isfile(self.get_game_file()) else False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>types.SimpleNamespace</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="clemcore.clemgame.GameSpec.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>spec: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a GameSpec from a dictionary. Can be used to directly create a GameSpec from a game registry entry.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameSpec.game_file_exists"><code class="name flex">
<span>def <span class="ident">game_file_exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if master.py can be located at the specified game_path</p></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.get_game_file"><code class="name flex">
<span>def <span class="ident">get_game_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main game file must be called master.py in game directory</p></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self, spec: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the game features match a given specification</p></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>model: <a title="clemcore.backends.Model" href="../backends/index.html#clemcore.backends.Model">Model</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A participant of a game. A player can respond via a custom implementation, human input or a language model:</p>
<ul>
<li>the programmatic players are called via the _custom_response() method</li>
<li>the human players are called via the _terminal_response() method</li>
<li>the backend players are called via the generate_response() method of the backend</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player(abc.ABC):
    &#34;&#34;&#34;
    A participant of a game. A player can respond via a custom implementation, human input or a language model:

    - the programmatic players are called via the _custom_response() method
    - the human players are called via the _terminal_response() method
    - the backend players are called via the generate_response() method of the backend
    &#34;&#34;&#34;

    def __init__(self, model: backends.Model):
        self.model = model
        self.descriptor: str = None
        logger.info(&#34;Player %s&#34;, self.get_description())

    def get_description(self) -&gt; str:
        return f&#34;{self.__class__.__name__}, {self.model}&#34;

    def __call__(self, messages: List[Dict], turn_idx) -&gt; Tuple[Any, Any, str]:
        call_start = datetime.now()
        prompt = messages
        response = dict()
        if isinstance(self.model, backends.CustomResponseModel):
            response_text = self._custom_response(messages, turn_idx)
        elif isinstance(self.model, backends.HumanModel):
            response_text = self._terminal_response(messages, turn_idx)
        else:
            prompt, response, response_text = self.model.generate_response(messages)
        call_duration = datetime.now() - call_start
        response[&#34;clem_player&#34;] = {
            &#34;call_start&#34;: str(call_start),
            &#34;call_duration&#34;: str(call_duration),
            &#34;response&#34;: response_text,
            &#34;model_name&#34;: self.model.get_name()
        }
        return prompt, response, response_text

    def _terminal_response(self, messages, turn_idx) -&gt; str:
        &#34;&#34;&#34;
        Overwrite this method to customize human inputs (model_name: human, terminal)
        :param messages: a list of dicts that contain the history of the conversation
        :param turn_idx: the index of the current turn
        :return: the human response as text
        &#34;&#34;&#34;
        latest_response = &#34;Nothing has been said yet.&#34;
        if messages:
            latest_response = messages[-1][&#34;content&#34;]
        print(f&#34;\n{latest_response}&#34;)
        user_input = input(f&#34;Your response as {self.__class__.__name__} (turn: {turn_idx}):\n&#34;)
        return user_input

    def _custom_response(self, messages, turn_idx) -&gt; str:
        &#34;&#34;&#34;
        Overwrite this method to implement programmatic behavior (model_name: mock, dry_run, programmatic, custom)
        :param messages: a list of dicts that contain the history of the conversation
        :param turn_idx: the index of the current turn
        :return: the programmatic response as text
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.Player.get_description"><code class="name flex">
<span>def <span class="ident">get_description</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clemcore" href="../index.html">clemcore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="clemcore.clemgame.metrics" href="metrics.html">clemcore.clemgame.metrics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clemcore.clemgame.is_game" href="#clemcore.clemgame.is_game">is_game</a></code></li>
<li><code><a title="clemcore.clemgame.load_custom_game_registry" href="#clemcore.clemgame.load_custom_game_registry">load_custom_game_registry</a></code></li>
<li><code><a title="clemcore.clemgame.load_game" href="#clemcore.clemgame.load_game">load_game</a></code></li>
<li><code><a title="clemcore.clemgame.load_game_registry" href="#clemcore.clemgame.load_game_registry">load_game_registry</a></code></li>
<li><code><a title="clemcore.clemgame.select_game" href="#clemcore.clemgame.select_game">select_game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clemcore.clemgame.DialogueGameMaster" href="#clemcore.clemgame.DialogueGameMaster">DialogueGameMaster</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.DialogueGameMaster.add_assistant_message" href="#clemcore.clemgame.DialogueGameMaster.add_assistant_message">add_assistant_message</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.add_message" href="#clemcore.clemgame.DialogueGameMaster.add_message">add_message</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.add_player" href="#clemcore.clemgame.DialogueGameMaster.add_player">add_player</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.add_user_message" href="#clemcore.clemgame.DialogueGameMaster.add_user_message">add_user_message</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_players" href="#clemcore.clemgame.DialogueGameMaster.get_players">get_players</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.log_message_to" href="#clemcore.clemgame.DialogueGameMaster.log_message_to">log_message_to</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.log_message_to_self" href="#clemcore.clemgame.DialogueGameMaster.log_message_to_self">log_message_to_self</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.log_to_self" href="#clemcore.clemgame.DialogueGameMaster.log_to_self">log_to_self</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.prompt" href="#clemcore.clemgame.DialogueGameMaster.prompt">prompt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameBenchmark" href="#clemcore.clemgame.GameBenchmark">GameBenchmark</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameBenchmark.build_transcripts" href="#clemcore.clemgame.GameBenchmark.build_transcripts">build_transcripts</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.compute_scores" href="#clemcore.clemgame.GameBenchmark.compute_scores">compute_scores</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.create_game_master" href="#clemcore.clemgame.GameBenchmark.create_game_master">create_game_master</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.create_game_scorer" href="#clemcore.clemgame.GameBenchmark.create_game_scorer">create_game_scorer</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.get_description" href="#clemcore.clemgame.GameBenchmark.get_description">get_description</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.is_single_player" href="#clemcore.clemgame.GameBenchmark.is_single_player">is_single_player</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.run" href="#clemcore.clemgame.GameBenchmark.run">run</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.setup" href="#clemcore.clemgame.GameBenchmark.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameInstanceGenerator" href="#clemcore.clemgame.GameInstanceGenerator">GameInstanceGenerator</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.add_experiment" href="#clemcore.clemgame.GameInstanceGenerator.add_experiment">add_experiment</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.add_game_instance" href="#clemcore.clemgame.GameInstanceGenerator.add_game_instance">add_game_instance</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.generate" href="#clemcore.clemgame.GameInstanceGenerator.generate">generate</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.on_generate" href="#clemcore.clemgame.GameInstanceGenerator.on_generate">on_generate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameMaster.play" href="#clemcore.clemgame.GameMaster.play">play</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.setup" href="#clemcore.clemgame.GameMaster.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameRecorder.interactions" href="#clemcore.clemgame.GameRecorder.interactions">interactions</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_current_turn" href="#clemcore.clemgame.GameRecorder.log_current_turn">log_current_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_event" href="#clemcore.clemgame.GameRecorder.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_key" href="#clemcore.clemgame.GameRecorder.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_next_turn" href="#clemcore.clemgame.GameRecorder.log_next_turn">log_next_turn</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_players" href="#clemcore.clemgame.GameRecorder.log_players">log_players</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.store_records" href="#clemcore.clemgame.GameRecorder.store_records">store_records</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameResourceLocator.file_path" href="#clemcore.clemgame.GameResourceLocator.file_path">file_path</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.results_path_for" href="#clemcore.clemgame.GameResourceLocator.results_path_for">results_path_for</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_results_file" href="#clemcore.clemgame.GameResourceLocator.store_results_file">store_results_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameScorer" href="#clemcore.clemgame.GameScorer">GameScorer</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameScorer.compute_scores" href="#clemcore.clemgame.GameScorer.compute_scores">compute_scores</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.game_instance" href="#clemcore.clemgame.GameScorer.game_instance">game_instance</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_episode_score" href="#clemcore.clemgame.GameScorer.log_episode_score">log_episode_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_main_score" href="#clemcore.clemgame.GameScorer.log_main_score">log_main_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_turn_score" href="#clemcore.clemgame.GameScorer.log_turn_score">log_turn_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_game" href="#clemcore.clemgame.GameScorer.score_game">score_game</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_game_end" href="#clemcore.clemgame.GameScorer.score_game_end">score_game_end</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_requests" href="#clemcore.clemgame.GameScorer.score_requests">score_requests</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_turns" href="#clemcore.clemgame.GameScorer.score_turns">score_turns</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.store_scores" href="#clemcore.clemgame.GameScorer.store_scores">store_scores</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameSpec" href="#clemcore.clemgame.GameSpec">GameSpec</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameSpec.from_dict" href="#clemcore.clemgame.GameSpec.from_dict">from_dict</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.game_file_exists" href="#clemcore.clemgame.GameSpec.game_file_exists">game_file_exists</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.get_game_file" href="#clemcore.clemgame.GameSpec.get_game_file">get_game_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.matches" href="#clemcore.clemgame.GameSpec.matches">matches</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.Player.get_description" href="#clemcore.clemgame.Player.get_description">get_description</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
